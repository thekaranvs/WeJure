{
"version":3,
"file":"module$node_modules$hash_base$node_modules$readable_stream$lib$_stream_writable.js",
"lineCount":22,
"mappings":"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",
"sources":["node_modules/hash-base/node_modules/readable-stream/lib/_stream_writable.js"],
"sourcesContent":["shadow$provide[\"module$node_modules$hash_base$node_modules$readable_stream$lib$_stream_writable\"] = function(global,require,module,exports) {\nvar process = require('process');\n// Copyright Joyent, Inc. and other Node contributors.\n//\n// Permission is hereby granted, free of charge, to any person obtaining a\n// copy of this software and associated documentation files (the\n// \"Software\"), to deal in the Software without restriction, including\n// without limitation the rights to use, copy, modify, merge, publish,\n// distribute, sublicense, and/or sell copies of the Software, and to permit\n// persons to whom the Software is furnished to do so, subject to the\n// following conditions:\n//\n// The above copyright notice and this permission notice shall be included\n// in all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS\n// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\n// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN\n// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,\n// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR\n// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE\n// USE OR OTHER DEALINGS IN THE SOFTWARE.\n// A bit simpler than readable streams.\n// Implement an async ._write(chunk, encoding, cb), and it'll handle all\n// the drain event emission and buffering.\n'use strict';\n\nmodule.exports = Writable;\n/* <replacement> */\n\nfunction WriteReq(chunk, encoding, cb) {\n  this.chunk = chunk;\n  this.encoding = encoding;\n  this.callback = cb;\n  this.next = null;\n} // It seems a linked list but it is not\n// there will be only 2 of these for each stream\n\n\nfunction CorkedRequest(state) {\n  var _this = this;\n\n  this.next = null;\n  this.entry = null;\n\n  this.finish = function () {\n    onCorkedFinish(_this, state);\n  };\n}\n/* </replacement> */\n\n/*<replacement>*/\n\n\nvar Duplex;\n/*</replacement>*/\n\nWritable.WritableState = WritableState;\n/*<replacement>*/\n\nvar internalUtil = {\n  deprecate: require('util-deprecate')\n};\n/*</replacement>*/\n\n/*<replacement>*/\n\nvar Stream = require('./internal/streams/stream');\n/*</replacement>*/\n\n\nvar Buffer = require('buffer').Buffer;\n\nvar OurUint8Array = global.Uint8Array || function () {};\n\nfunction _uint8ArrayToBuffer(chunk) {\n  return Buffer.from(chunk);\n}\n\nfunction _isUint8Array(obj) {\n  return Buffer.isBuffer(obj) || obj instanceof OurUint8Array;\n}\n\nvar destroyImpl = require('./internal/streams/destroy');\n\nvar _require = require('./internal/streams/state'),\n    getHighWaterMark = _require.getHighWaterMark;\n\nvar _require$codes = require('../errors').codes,\n    ERR_INVALID_ARG_TYPE = _require$codes.ERR_INVALID_ARG_TYPE,\n    ERR_METHOD_NOT_IMPLEMENTED = _require$codes.ERR_METHOD_NOT_IMPLEMENTED,\n    ERR_MULTIPLE_CALLBACK = _require$codes.ERR_MULTIPLE_CALLBACK,\n    ERR_STREAM_CANNOT_PIPE = _require$codes.ERR_STREAM_CANNOT_PIPE,\n    ERR_STREAM_DESTROYED = _require$codes.ERR_STREAM_DESTROYED,\n    ERR_STREAM_NULL_VALUES = _require$codes.ERR_STREAM_NULL_VALUES,\n    ERR_STREAM_WRITE_AFTER_END = _require$codes.ERR_STREAM_WRITE_AFTER_END,\n    ERR_UNKNOWN_ENCODING = _require$codes.ERR_UNKNOWN_ENCODING;\n\nvar errorOrDestroy = destroyImpl.errorOrDestroy;\n\nrequire('inherits')(Writable, Stream);\n\nfunction nop() {}\n\nfunction WritableState(options, stream, isDuplex) {\n  Duplex = Duplex || require('./_stream_duplex');\n  options = options || {}; // Duplex streams are both readable and writable, but share\n  // the same options object.\n  // However, some cases require setting options to different\n  // values for the readable and the writable sides of the duplex stream,\n  // e.g. options.readableObjectMode vs. options.writableObjectMode, etc.\n\n  if (typeof isDuplex !== 'boolean') isDuplex = stream instanceof Duplex; // object stream flag to indicate whether or not this stream\n  // contains buffers or objects.\n\n  this.objectMode = !!options.objectMode;\n  if (isDuplex) this.objectMode = this.objectMode || !!options.writableObjectMode; // the point at which write() starts returning false\n  // Note: 0 is a valid value, means that we always return false if\n  // the entire buffer is not flushed immediately on write()\n\n  this.highWaterMark = getHighWaterMark(this, options, 'writableHighWaterMark', isDuplex); // if _final has been called\n\n  this.finalCalled = false; // drain event flag.\n\n  this.needDrain = false; // at the start of calling end()\n\n  this.ending = false; // when end() has been called, and returned\n\n  this.ended = false; // when 'finish' is emitted\n\n  this.finished = false; // has it been destroyed\n\n  this.destroyed = false; // should we decode strings into buffers before passing to _write?\n  // this is here so that some node-core streams can optimize string\n  // handling at a lower level.\n\n  var noDecode = options.decodeStrings === false;\n  this.decodeStrings = !noDecode; // Crypto is kind of old and crusty.  Historically, its default string\n  // encoding is 'binary' so we have to make this configurable.\n  // Everything else in the universe uses 'utf8', though.\n\n  this.defaultEncoding = options.defaultEncoding || 'utf8'; // not an actual buffer we keep track of, but a measurement\n  // of how much we're waiting to get pushed to some underlying\n  // socket or file.\n\n  this.length = 0; // a flag to see when we're in the middle of a write.\n\n  this.writing = false; // when true all writes will be buffered until .uncork() call\n\n  this.corked = 0; // a flag to be able to tell if the onwrite cb is called immediately,\n  // or on a later tick.  We set this to true at first, because any\n  // actions that shouldn't happen until \"later\" should generally also\n  // not happen before the first write call.\n\n  this.sync = true; // a flag to know if we're processing previously buffered items, which\n  // may call the _write() callback in the same tick, so that we don't\n  // end up in an overlapped onwrite situation.\n\n  this.bufferProcessing = false; // the callback that's passed to _write(chunk,cb)\n\n  this.onwrite = function (er) {\n    onwrite(stream, er);\n  }; // the callback that the user supplies to write(chunk,encoding,cb)\n\n\n  this.writecb = null; // the amount that is being written when _write is called.\n\n  this.writelen = 0;\n  this.bufferedRequest = null;\n  this.lastBufferedRequest = null; // number of pending user-supplied write callbacks\n  // this must be 0 before 'finish' can be emitted\n\n  this.pendingcb = 0; // emit prefinish if the only thing we're waiting for is _write cbs\n  // This is relevant for synchronous Transform streams\n\n  this.prefinished = false; // True if the error was already emitted and should not be thrown again\n\n  this.errorEmitted = false; // Should close be emitted on destroy. Defaults to true.\n\n  this.emitClose = options.emitClose !== false; // Should .destroy() be called after 'finish' (and potentially 'end')\n\n  this.autoDestroy = !!options.autoDestroy; // count buffered requests\n\n  this.bufferedRequestCount = 0; // allocate the first CorkedRequest, there is always\n  // one allocated and free to use, and we maintain at most two\n\n  this.corkedRequestsFree = new CorkedRequest(this);\n}\n\nWritableState.prototype.getBuffer = function getBuffer() {\n  var current = this.bufferedRequest;\n  var out = [];\n\n  while (current) {\n    out.push(current);\n    current = current.next;\n  }\n\n  return out;\n};\n\n(function () {\n  try {\n    Object.defineProperty(WritableState.prototype, 'buffer', {\n      get: internalUtil.deprecate(function writableStateBufferGetter() {\n        return this.getBuffer();\n      }, '_writableState.buffer is deprecated. Use _writableState.getBuffer ' + 'instead.', 'DEP0003')\n    });\n  } catch (_) {}\n})(); // Test _writableState for inheritance to account for Duplex streams,\n// whose prototype chain only points to Readable.\n\n\nvar realHasInstance;\n\nif (typeof Symbol === 'function' && Symbol.hasInstance && typeof Function.prototype[Symbol.hasInstance] === 'function') {\n  realHasInstance = Function.prototype[Symbol.hasInstance];\n  Object.defineProperty(Writable, Symbol.hasInstance, {\n    value: function value(object) {\n      if (realHasInstance.call(this, object)) return true;\n      if (this !== Writable) return false;\n      return object && object._writableState instanceof WritableState;\n    }\n  });\n} else {\n  realHasInstance = function realHasInstance(object) {\n    return object instanceof this;\n  };\n}\n\nfunction Writable(options) {\n  Duplex = Duplex || require('./_stream_duplex'); // Writable ctor is applied to Duplexes, too.\n  // `realHasInstance` is necessary because using plain `instanceof`\n  // would return false, as no `_writableState` property is attached.\n  // Trying to use the custom `instanceof` for Writable here will also break the\n  // Node.js LazyTransform implementation, which has a non-trivial getter for\n  // `_writableState` that would lead to infinite recursion.\n  // Checking for a Stream.Duplex instance is faster here instead of inside\n  // the WritableState constructor, at least with V8 6.5\n\n  var isDuplex = this instanceof Duplex;\n  if (!isDuplex && !realHasInstance.call(Writable, this)) return new Writable(options);\n  this._writableState = new WritableState(options, this, isDuplex); // legacy.\n\n  this.writable = true;\n\n  if (options) {\n    if (typeof options.write === 'function') this._write = options.write;\n    if (typeof options.writev === 'function') this._writev = options.writev;\n    if (typeof options.destroy === 'function') this._destroy = options.destroy;\n    if (typeof options.final === 'function') this._final = options.final;\n  }\n\n  Stream.call(this);\n} // Otherwise people can pipe Writable streams, which is just wrong.\n\n\nWritable.prototype.pipe = function () {\n  errorOrDestroy(this, new ERR_STREAM_CANNOT_PIPE());\n};\n\nfunction writeAfterEnd(stream, cb) {\n  var er = new ERR_STREAM_WRITE_AFTER_END(); // TODO: defer error events consistently everywhere, not just the cb\n\n  errorOrDestroy(stream, er);\n  process.nextTick(cb, er);\n} // Checks that a user-supplied chunk is valid, especially for the particular\n// mode the stream is in. Currently this means that `null` is never accepted\n// and undefined/non-string values are only allowed in object mode.\n\n\nfunction validChunk(stream, state, chunk, cb) {\n  var er;\n\n  if (chunk === null) {\n    er = new ERR_STREAM_NULL_VALUES();\n  } else if (typeof chunk !== 'string' && !state.objectMode) {\n    er = new ERR_INVALID_ARG_TYPE('chunk', ['string', 'Buffer'], chunk);\n  }\n\n  if (er) {\n    errorOrDestroy(stream, er);\n    process.nextTick(cb, er);\n    return false;\n  }\n\n  return true;\n}\n\nWritable.prototype.write = function (chunk, encoding, cb) {\n  var state = this._writableState;\n  var ret = false;\n\n  var isBuf = !state.objectMode && _isUint8Array(chunk);\n\n  if (isBuf && !Buffer.isBuffer(chunk)) {\n    chunk = _uint8ArrayToBuffer(chunk);\n  }\n\n  if (typeof encoding === 'function') {\n    cb = encoding;\n    encoding = null;\n  }\n\n  if (isBuf) encoding = 'buffer';else if (!encoding) encoding = state.defaultEncoding;\n  if (typeof cb !== 'function') cb = nop;\n  if (state.ending) writeAfterEnd(this, cb);else if (isBuf || validChunk(this, state, chunk, cb)) {\n    state.pendingcb++;\n    ret = writeOrBuffer(this, state, isBuf, chunk, encoding, cb);\n  }\n  return ret;\n};\n\nWritable.prototype.cork = function () {\n  this._writableState.corked++;\n};\n\nWritable.prototype.uncork = function () {\n  var state = this._writableState;\n\n  if (state.corked) {\n    state.corked--;\n    if (!state.writing && !state.corked && !state.bufferProcessing && state.bufferedRequest) clearBuffer(this, state);\n  }\n};\n\nWritable.prototype.setDefaultEncoding = function setDefaultEncoding(encoding) {\n  // node::ParseEncoding() requires lower case.\n  if (typeof encoding === 'string') encoding = encoding.toLowerCase();\n  if (!(['hex', 'utf8', 'utf-8', 'ascii', 'binary', 'base64', 'ucs2', 'ucs-2', 'utf16le', 'utf-16le', 'raw'].indexOf((encoding + '').toLowerCase()) > -1)) throw new ERR_UNKNOWN_ENCODING(encoding);\n  this._writableState.defaultEncoding = encoding;\n  return this;\n};\n\nObject.defineProperty(Writable.prototype, 'writableBuffer', {\n  // making it explicit this property is not enumerable\n  // because otherwise some prototype manipulation in\n  // userland will fail\n  enumerable: false,\n  get: function get() {\n    return this._writableState && this._writableState.getBuffer();\n  }\n});\n\nfunction decodeChunk(state, chunk, encoding) {\n  if (!state.objectMode && state.decodeStrings !== false && typeof chunk === 'string') {\n    chunk = Buffer.from(chunk, encoding);\n  }\n\n  return chunk;\n}\n\nObject.defineProperty(Writable.prototype, 'writableHighWaterMark', {\n  // making it explicit this property is not enumerable\n  // because otherwise some prototype manipulation in\n  // userland will fail\n  enumerable: false,\n  get: function get() {\n    return this._writableState.highWaterMark;\n  }\n}); // if we're already writing something, then just put this\n// in the queue, and wait our turn.  Otherwise, call _write\n// If we return false, then we need a drain event, so set that flag.\n\nfunction writeOrBuffer(stream, state, isBuf, chunk, encoding, cb) {\n  if (!isBuf) {\n    var newChunk = decodeChunk(state, chunk, encoding);\n\n    if (chunk !== newChunk) {\n      isBuf = true;\n      encoding = 'buffer';\n      chunk = newChunk;\n    }\n  }\n\n  var len = state.objectMode ? 1 : chunk.length;\n  state.length += len;\n  var ret = state.length < state.highWaterMark; // we must ensure that previous needDrain will not be reset to false.\n\n  if (!ret) state.needDrain = true;\n\n  if (state.writing || state.corked) {\n    var last = state.lastBufferedRequest;\n    state.lastBufferedRequest = {\n      chunk: chunk,\n      encoding: encoding,\n      isBuf: isBuf,\n      callback: cb,\n      next: null\n    };\n\n    if (last) {\n      last.next = state.lastBufferedRequest;\n    } else {\n      state.bufferedRequest = state.lastBufferedRequest;\n    }\n\n    state.bufferedRequestCount += 1;\n  } else {\n    doWrite(stream, state, false, len, chunk, encoding, cb);\n  }\n\n  return ret;\n}\n\nfunction doWrite(stream, state, writev, len, chunk, encoding, cb) {\n  state.writelen = len;\n  state.writecb = cb;\n  state.writing = true;\n  state.sync = true;\n  if (state.destroyed) state.onwrite(new ERR_STREAM_DESTROYED('write'));else if (writev) stream._writev(chunk, state.onwrite);else stream._write(chunk, encoding, state.onwrite);\n  state.sync = false;\n}\n\nfunction onwriteError(stream, state, sync, er, cb) {\n  --state.pendingcb;\n\n  if (sync) {\n    // defer the callback if we are being called synchronously\n    // to avoid piling up things on the stack\n    process.nextTick(cb, er); // this can emit finish, and it will always happen\n    // after error\n\n    process.nextTick(finishMaybe, stream, state);\n    stream._writableState.errorEmitted = true;\n    errorOrDestroy(stream, er);\n  } else {\n    // the caller expect this to happen before if\n    // it is async\n    cb(er);\n    stream._writableState.errorEmitted = true;\n    errorOrDestroy(stream, er); // this can emit finish, but finish must\n    // always follow error\n\n    finishMaybe(stream, state);\n  }\n}\n\nfunction onwriteStateUpdate(state) {\n  state.writing = false;\n  state.writecb = null;\n  state.length -= state.writelen;\n  state.writelen = 0;\n}\n\nfunction onwrite(stream, er) {\n  var state = stream._writableState;\n  var sync = state.sync;\n  var cb = state.writecb;\n  if (typeof cb !== 'function') throw new ERR_MULTIPLE_CALLBACK();\n  onwriteStateUpdate(state);\n  if (er) onwriteError(stream, state, sync, er, cb);else {\n    // Check if we're actually ready to finish, but don't emit yet\n    var finished = needFinish(state) || stream.destroyed;\n\n    if (!finished && !state.corked && !state.bufferProcessing && state.bufferedRequest) {\n      clearBuffer(stream, state);\n    }\n\n    if (sync) {\n      process.nextTick(afterWrite, stream, state, finished, cb);\n    } else {\n      afterWrite(stream, state, finished, cb);\n    }\n  }\n}\n\nfunction afterWrite(stream, state, finished, cb) {\n  if (!finished) onwriteDrain(stream, state);\n  state.pendingcb--;\n  cb();\n  finishMaybe(stream, state);\n} // Must force callback to be called on nextTick, so that we don't\n// emit 'drain' before the write() consumer gets the 'false' return\n// value, and has a chance to attach a 'drain' listener.\n\n\nfunction onwriteDrain(stream, state) {\n  if (state.length === 0 && state.needDrain) {\n    state.needDrain = false;\n    stream.emit('drain');\n  }\n} // if there's something in the buffer waiting, then process it\n\n\nfunction clearBuffer(stream, state) {\n  state.bufferProcessing = true;\n  var entry = state.bufferedRequest;\n\n  if (stream._writev && entry && entry.next) {\n    // Fast case, write everything using _writev()\n    var l = state.bufferedRequestCount;\n    var buffer = new Array(l);\n    var holder = state.corkedRequestsFree;\n    holder.entry = entry;\n    var count = 0;\n    var allBuffers = true;\n\n    while (entry) {\n      buffer[count] = entry;\n      if (!entry.isBuf) allBuffers = false;\n      entry = entry.next;\n      count += 1;\n    }\n\n    buffer.allBuffers = allBuffers;\n    doWrite(stream, state, true, state.length, buffer, '', holder.finish); // doWrite is almost always async, defer these to save a bit of time\n    // as the hot path ends with doWrite\n\n    state.pendingcb++;\n    state.lastBufferedRequest = null;\n\n    if (holder.next) {\n      state.corkedRequestsFree = holder.next;\n      holder.next = null;\n    } else {\n      state.corkedRequestsFree = new CorkedRequest(state);\n    }\n\n    state.bufferedRequestCount = 0;\n  } else {\n    // Slow case, write chunks one-by-one\n    while (entry) {\n      var chunk = entry.chunk;\n      var encoding = entry.encoding;\n      var cb = entry.callback;\n      var len = state.objectMode ? 1 : chunk.length;\n      doWrite(stream, state, false, len, chunk, encoding, cb);\n      entry = entry.next;\n      state.bufferedRequestCount--; // if we didn't call the onwrite immediately, then\n      // it means that we need to wait until it does.\n      // also, that means that the chunk and cb are currently\n      // being processed, so move the buffer counter past them.\n\n      if (state.writing) {\n        break;\n      }\n    }\n\n    if (entry === null) state.lastBufferedRequest = null;\n  }\n\n  state.bufferedRequest = entry;\n  state.bufferProcessing = false;\n}\n\nWritable.prototype._write = function (chunk, encoding, cb) {\n  cb(new ERR_METHOD_NOT_IMPLEMENTED('_write()'));\n};\n\nWritable.prototype._writev = null;\n\nWritable.prototype.end = function (chunk, encoding, cb) {\n  var state = this._writableState;\n\n  if (typeof chunk === 'function') {\n    cb = chunk;\n    chunk = null;\n    encoding = null;\n  } else if (typeof encoding === 'function') {\n    cb = encoding;\n    encoding = null;\n  }\n\n  if (chunk !== null && chunk !== undefined) this.write(chunk, encoding); // .end() fully uncorks\n\n  if (state.corked) {\n    state.corked = 1;\n    this.uncork();\n  } // ignore unnecessary end() calls.\n\n\n  if (!state.ending) endWritable(this, state, cb);\n  return this;\n};\n\nObject.defineProperty(Writable.prototype, 'writableLength', {\n  // making it explicit this property is not enumerable\n  // because otherwise some prototype manipulation in\n  // userland will fail\n  enumerable: false,\n  get: function get() {\n    return this._writableState.length;\n  }\n});\n\nfunction needFinish(state) {\n  return state.ending && state.length === 0 && state.bufferedRequest === null && !state.finished && !state.writing;\n}\n\nfunction callFinal(stream, state) {\n  stream._final(function (err) {\n    state.pendingcb--;\n\n    if (err) {\n      errorOrDestroy(stream, err);\n    }\n\n    state.prefinished = true;\n    stream.emit('prefinish');\n    finishMaybe(stream, state);\n  });\n}\n\nfunction prefinish(stream, state) {\n  if (!state.prefinished && !state.finalCalled) {\n    if (typeof stream._final === 'function' && !state.destroyed) {\n      state.pendingcb++;\n      state.finalCalled = true;\n      process.nextTick(callFinal, stream, state);\n    } else {\n      state.prefinished = true;\n      stream.emit('prefinish');\n    }\n  }\n}\n\nfunction finishMaybe(stream, state) {\n  var need = needFinish(state);\n\n  if (need) {\n    prefinish(stream, state);\n\n    if (state.pendingcb === 0) {\n      state.finished = true;\n      stream.emit('finish');\n\n      if (state.autoDestroy) {\n        // In case of duplex streams we need a way to detect\n        // if the readable side is ready for autoDestroy as well\n        var rState = stream._readableState;\n\n        if (!rState || rState.autoDestroy && rState.endEmitted) {\n          stream.destroy();\n        }\n      }\n    }\n  }\n\n  return need;\n}\n\nfunction endWritable(stream, state, cb) {\n  state.ending = true;\n  finishMaybe(stream, state);\n\n  if (cb) {\n    if (state.finished) process.nextTick(cb);else stream.once('finish', cb);\n  }\n\n  state.ended = true;\n  stream.writable = false;\n}\n\nfunction onCorkedFinish(corkReq, state, err) {\n  var entry = corkReq.entry;\n  corkReq.entry = null;\n\n  while (entry) {\n    var cb = entry.callback;\n    state.pendingcb--;\n    cb(err);\n    entry = entry.next;\n  } // reuse the free corkReq.\n\n\n  state.corkedRequestsFree.next = corkReq;\n}\n\nObject.defineProperty(Writable.prototype, 'destroyed', {\n  // making it explicit this property is not enumerable\n  // because otherwise some prototype manipulation in\n  // userland will fail\n  enumerable: false,\n  get: function get() {\n    if (this._writableState === undefined) {\n      return false;\n    }\n\n    return this._writableState.destroyed;\n  },\n  set: function set(value) {\n    // we ignore the value if the stream\n    // has not been initialized yet\n    if (!this._writableState) {\n      return;\n    } // backward compatibility, the user is explicitly\n    // managing destroyed\n\n\n    this._writableState.destroyed = value;\n  }\n});\nWritable.prototype.destroy = destroyImpl.destroy;\nWritable.prototype._undestroy = destroyImpl.undestroy;\n\nWritable.prototype._destroy = function (err, cb) {\n  cb(err);\n};\n};"],
"names":["shadow$provide","global","require","module","exports","CorkedRequest","state","_this","entry","next","finish","this.finish","cb","callback","pendingcb","err","corkedRequestsFree","nop","WritableState","options","stream","isDuplex","Duplex","objectMode","writableObjectMode","highWaterMark","getHighWaterMark","destroyed","finished","ended","ending","needDrain","finalCalled","decodeStrings","defaultEncoding","length","writing","corked","sync","bufferProcessing","onwrite","this.onwrite","er","_writableState","writecb","ERR_MULTIPLE_CALLBACK","writelen","process","nextTick","finishMaybe","errorEmitted","errorOrDestroy","needFinish","bufferedRequest","clearBuffer","afterWrite","lastBufferedRequest","prefinished","emitClose","autoDestroy","bufferedRequestCount","Writable","realHasInstance","call","writable","write","_write","writev","_writev","destroy","_destroy","final","_final","Stream","doWrite","len","chunk","encoding","ERR_STREAM_DESTROYED","emit","buffer","Array","holder","count","allBuffers","isBuf","callFinal","need","rState","_readableState","endEmitted","internalUtil","deprecate","Buffer","OurUint8Array","Uint8Array","destroyImpl","_require","_require$codes","codes","ERR_INVALID_ARG_TYPE","ERR_METHOD_NOT_IMPLEMENTED","ERR_STREAM_CANNOT_PIPE","ERR_STREAM_NULL_VALUES","ERR_STREAM_WRITE_AFTER_END","ERR_UNKNOWN_ENCODING","prototype","getBuffer","WritableState.prototype.getBuffer","current","out","push","Object","defineProperty","get","writableStateBufferGetter","_","Symbol","hasInstance","Function","value","object","pipe","Writable.prototype.pipe","Writable.prototype.write","ret","isBuffer","obj","from","newChunk","last","cork","Writable.prototype.cork","uncork","Writable.prototype.uncork","setDefaultEncoding","Writable.prototype.setDefaultEncoding","toLowerCase","indexOf","enumerable","Writable.prototype._write","end","Writable.prototype.end","undefined","once","set","_undestroy","undestroy","Writable.prototype._destroy"]
}
